package com.lll.concurent;

/**
 * Version 1.0
 * Created by lll on 14/12/2017.
 * Description
 * <p>
 * Volatile关键字总结
 * <p>
 * <p>
 * <p>
 * copyright generalray4239@gmail.com
 */
public class VolatileLearn {

  /***
   * 一、线程之间的通信：
   *    1、java的内存模型简单介绍：
   *       java中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域。因此它存在内存可见性问题。
   *      而局部变量和方法定义的参数存储在栈区，不会被线程之间共享，他们不会有内存可见性问题。
   *    2、java内存模型定义了线程和主存之间的抽象关系：
   *       线程之间的共享变量存储在主存中，每一个线程都有一个私有的本地内存，本地内存存储了该线程共享变量的副本。
   *    3、线程A 要与线程B之间的通信：
   *       1、A把A本地内存(工作内存)中更新过的共享变量刷新到主存中。
   *       2、B去主存中读取数据。
   */


  /**
   * 二、原子性
   * 1、对基本数据类型变量的读取和赋值操作是原子性操作。这些操作是不能被中断的。
   */
  public void test() {
    int x = 3;//原子性操作
    int y = x;//不是原子操作，包含读取x的值，和将x的值写入工作内存，是两个操作，每一个操作都是原子操作，但是合起来就不是了。
    x++; //不是原子操作，
  }

  /**
   * 三、可见性：
   *    指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。（也就是一个线程修改的结果，另一个线程马上就可以看到）
   *
   *    1、当一个共享变量被volatile修饰时，它会保证修改的值，立即更新到主存。普通的共享变量不能保证可见性
   */


  /**
   * 四、有序性
   *     每个时刻只有一个线程执行同步代码。就是有序性。通过锁机制实现。
   */

  /**
   * 五、volatile总结
   * 1、保证可见性
   * 2、保证有序性
   * 注意：volatile不保证原子性：
   * <p>
   * 3、使用Volatile的两个条件:
   * 1、对变量的写操作不依赖变量的当前值。
   * 2、改变量没有包含在具有其他变量的不变式中
   */

  public volatile boolean isStop = false;

  public void testRunn() {
    new Thread() {
      @Override
      public void run() {
        while (!isStop) {
          System.out.println("线程一直在执行");
        }
      }
    }.start();
  }


}
